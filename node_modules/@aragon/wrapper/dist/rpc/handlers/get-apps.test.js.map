{"version":3,"sources":["../../../src/rpc/handlers/get-apps.test.js"],"names":["test","afterEach","always","sinon","restore","t","plan","initialApps","appId","kernelAddress","contractAddress","abi","isForwarder","name","proxyAddress","icons","src","appsMock","BehaviorSubject","identifiersMock","result","params","apm","getContentPath","content","path","apps","appIdentifiers","expectedInitialApps","appAddress","appImplementationAddress","identifier","expectedEndApps","concat","emitIndex","subscribe","value","deepEqual","fail","endApps","next","icon","expectedApps","currentAppAddress","initialApp","address","endApp"],"mappings":"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","sourcesContent":["import test from 'ava'\nimport sinon from 'sinon'\nimport { of, BehaviorSubject } from 'rxjs'\n\nimport getApps from './get-apps'\n\ntest.afterEach.always(() => {\n  sinon.restore()\n})\n\ntest('should return a subscription for the entire app list if observing all', async (t) => {\n  t.plan(2)\n\n  // arrange\n  const initialApps = [{\n    appId: 'coolApp',\n    kernelAddress: '0x123',\n    contractAddress: '0xcoolApp',\n    abi: 'abi for coolApp',\n    isForwarder: false,\n    name: 'Cool App',\n    proxyAddress: '0x456',\n    icons: [{ src: 'icon_link' }]\n  }]\n  const appsMock = new BehaviorSubject(initialApps)\n  const identifiersMock = of({\n    '0x456': 'cool identifier',\n    '0x789': 'voting identifier'\n  })\n\n  const requestStub = {\n    params: ['observe', 'all']\n  }\n  const proxyStub = {}\n  const wrapperStub = {\n    apm: {\n      getContentPath: (content, path) => `url/${path}`\n    },\n    apps: appsMock,\n    appIdentifiers: identifiersMock\n  }\n\n  // act\n  const result = await getApps(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  const expectedInitialApps = [{\n    appAddress: '0x456',\n    appId: 'coolApp',\n    appImplementationAddress: '0xcoolApp',\n    identifier: 'cool identifier',\n    isForwarder: false,\n    kernelAddress: '0x123',\n    name: 'Cool App',\n    icons: [{ src: 'url/icon_link' }]\n  }]\n  const expectedEndApps = [].concat(expectedInitialApps, {\n    appAddress: '0x789',\n    appId: 'votingApp',\n    appImplementationAddress: '0xvotingApp',\n    identifier: 'voting identifier',\n    isForwarder: true,\n    kernelAddress: '0x123',\n    name: 'Voting App',\n    icons: [{ src: 'url/icon_link' }]\n  })\n  let emitIndex = 0\n  result.subscribe(value => {\n    if (emitIndex === 0) {\n      t.deepEqual(value, expectedInitialApps)\n    } else if (emitIndex === 1) {\n      t.deepEqual(value, expectedEndApps)\n    } else {\n      t.fail('too many emissions')\n    }\n\n    emitIndex++\n  })\n\n  // We need apps' second emission to fire after the identifiers have emitted,\n  // so that the combineLatest doesn't skip the initial value\n  const endApps = [].concat(initialApps, {\n    appId: 'votingApp',\n    kernelAddress: '0x123',\n    contractAddress: '0xvotingApp',\n    abi: 'abi for votingApp',\n    isForwarder: true,\n    name: 'Voting App',\n    proxyAddress: '0x789',\n    icons: [{ src: 'icon_link' }]\n  })\n  appsMock.next(endApps)\n})\n\ntest('should return a subscription for the entire app list via initial RPC API', async (t) => {\n  t.plan(2)\n\n  // arrange\n  const initialApps = [{\n    appId: 'coolApp',\n    kernelAddress: '0x123',\n    contractAddress: '0xcoolApp',\n    abi: 'abi for coolApp',\n    isForwarder: false,\n    name: 'Cool App',\n    icon: 'icon link',\n    proxyAddress: '0x456'\n  }]\n  const endApps = [].concat(initialApps, {\n    appId: 'votingApp',\n    kernelAddress: '0x123',\n    contractAddress: '0xvotingApp',\n    abi: 'abi for votingApp',\n    isForwarder: true,\n    name: 'Voting App',\n    icon: 'icon link',\n    proxyAddress: '0x789'\n  })\n  const appsMock = of(initialApps, endApps)\n\n  const requestStub = {\n    params: []\n  }\n  const proxyStub = {}\n  const wrapperStub = {\n    apps: appsMock\n  }\n\n  // act\n  const result = await getApps(requestStub, proxyStub, wrapperStub)\n  // assert\n  let emitIndex = 0\n  result.subscribe(value => {\n    if (emitIndex === 0) {\n      t.deepEqual(value, initialApps)\n    } else if (emitIndex === 1) {\n      t.deepEqual(value, endApps)\n    } else {\n      t.fail('too many emissions')\n    }\n\n    emitIndex++\n  })\n})\n\ntest('should return the initial value for the entire app list if getting all', async (t) => {\n  t.plan(1)\n\n  // arrange\n  const initialApps = [{\n    appId: 'coolApp',\n    kernelAddress: '0x123',\n    contractAddress: '0xcoolApp',\n    abi: 'abi for coolApp',\n    isForwarder: false,\n    name: 'Cool App',\n    proxyAddress: '0x456',\n    icons: [{ src: 'icon_link' }]\n  }]\n  const appsMock = new BehaviorSubject(initialApps)\n  const identifiersMock = of({\n    '0x456': 'cool identifier',\n    '0x789': 'voting identifier'\n  })\n\n  const requestStub = {\n    params: ['get', 'all']\n  }\n  const proxyStub = {}\n  const wrapperStub = {\n    apm: {\n      getContentPath: (content, path) => `url/${path}`\n    },\n    apps: appsMock,\n    appIdentifiers: identifiersMock\n  }\n\n  // act\n  const result = await getApps(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  const expectedApps = [{\n    appAddress: '0x456',\n    appId: 'coolApp',\n    appImplementationAddress: '0xcoolApp',\n    identifier: 'cool identifier',\n    isForwarder: false,\n    kernelAddress: '0x123',\n    name: 'Cool App',\n    icons: [{ src: 'url/icon_link' }]\n  }]\n  let emitIndex = 0\n  result.subscribe(value => {\n    if (emitIndex === 0) {\n      t.deepEqual(value, expectedApps)\n    } else {\n      t.fail('too many emissions')\n    }\n\n    emitIndex++\n  })\n\n  // Even though this is filtered out, we need apps' second emission to fire after the identifiers\n  // have emitted, so that the combineLatest doesn't skip the initial value\n  const endApps = [].concat(initialApps, {\n    appId: 'votingApp',\n    kernelAddress: '0x123',\n    contractAddress: '0xvotingApp',\n    abi: 'abi for votingApp',\n    isForwarder: true,\n    name: 'Voting App',\n    proxyAddress: '0x789',\n    icons: [{ src: 'icon_link' }]\n  })\n  appsMock.next(endApps)\n})\n\ntest('should return a subscription for just the current app if observing current', async (t) => {\n  t.plan(2)\n\n  // arrange\n  const currentAppAddress = '0x456'\n  const initialApp = {\n    appId: 'coolApp',\n    contractAddress: '0xcoolApp',\n    kernelAddress: '0x123',\n    abi: 'abi for coolApp',\n    isForwarder: false,\n    name: 'Cool App',\n    proxyAddress: currentAppAddress,\n    icons: [{ src: 'icon_link' }]\n  }\n  const appsMock = new BehaviorSubject([initialApp])\n  const identifiersMock = of({\n    '0x456': 'cool identifier'\n  })\n\n  const requestStub = {\n    params: ['observe', 'current']\n  }\n  const proxyStub = {\n    address: currentAppAddress\n  }\n  const wrapperStub = {\n    apm: {\n      getContentPath: (content, path) => `url/${path}`\n    },\n    apps: appsMock,\n    appIdentifiers: identifiersMock\n  }\n\n  // act\n  const result = await getApps(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  let emitIndex = 0\n  result.subscribe(value => {\n    if (emitIndex === 0) {\n      t.deepEqual(value, {\n        appAddress: currentAppAddress,\n        appId: 'coolApp',\n        appImplementationAddress: '0xcoolApp',\n        identifier: 'cool identifier',\n        isForwarder: false,\n        kernelAddress: '0x123',\n        name: 'Cool App',\n        icons: [{ src: 'url/icon_link' }]\n      })\n    } else if (emitIndex === 1) {\n      t.deepEqual(value, {\n        appAddress: currentAppAddress,\n        appId: 'new coolApp',\n        appImplementationAddress: '0xcoolApp',\n        identifier: 'cool identifier',\n        isForwarder: false,\n        kernelAddress: '0x123',\n        name: 'Cool App',\n        icons: [{ src: 'url/icon_link' }]\n      })\n    } else {\n      t.fail('too many emissions')\n    }\n\n    emitIndex++\n  })\n\n  // We need apps' second emission to fire after the identifiers have emitted,\n  // so that the combineLatest doesn't skip the initial value\n  const endApp = {\n    ...initialApp,\n    appId: 'new coolApp'\n  }\n  appsMock.next([\n    // This extra app should be filtered out\n    {\n      appId: 'votingApp',\n      kernelAddress: '0x123',\n      contractAddress: '0xvotingApp',\n      abi: 'abi for votingApp',\n      isForwarder: true,\n      name: 'Voting App',\n      proxyAddress: '0x789',\n      icons: [{ src: 'icon_link' }]\n    },\n    endApp\n  ])\n})\n\ntest('should return the initial value for just the current app if getting current', async (t) => {\n  t.plan(1)\n\n  // arrange\n  const currentAppAddress = '0x456'\n  const initialApp = {\n    appId: 'coolApp',\n    contractAddress: '0xcoolApp',\n    kernelAddress: '0x123',\n    abi: 'abi for coolApp',\n    isForwarder: false,\n    name: 'Cool App',\n    proxyAddress: currentAppAddress,\n    icons: [{ src: 'icon_link' }]\n  }\n  const endApp = {\n    ...initialApp,\n    appId: 'new coolApp'\n  }\n  const appsMock = new BehaviorSubject([initialApp])\n  const identifiersMock = of({\n    '0x456': 'cool identifier'\n  })\n\n  const requestStub = {\n    params: ['get', 'current']\n  }\n  const proxyStub = {\n    address: currentAppAddress\n  }\n  const wrapperStub = {\n    apm: {\n      getContentPath: (content, path) => `url/${path}`\n    },\n    apps: appsMock,\n    appIdentifiers: identifiersMock\n  }\n\n  // act\n  const result = await getApps(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  let emitIndex = 0\n  result.subscribe(value => {\n    if (emitIndex === 0) {\n      t.deepEqual(value, {\n        appAddress: currentAppAddress,\n        appId: 'coolApp',\n        appImplementationAddress: '0xcoolApp',\n        identifier: 'cool identifier',\n        isForwarder: false,\n        kernelAddress: '0x123',\n        name: 'Cool App',\n        icons: [{ src: 'url/icon_link' }]\n      })\n    } else {\n      t.fail('too many emissions')\n    }\n\n    emitIndex++\n  })\n\n  // Even though this is filtered out, we need apps' second emission to fire after the identifiers\n  // have emitted, so that the combineLatest doesn't skip the initial value\n  appsMock.next([endApp])\n})\n"],"file":"get-apps.test.js"}