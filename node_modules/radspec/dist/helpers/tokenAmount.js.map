{"version":3,"sources":["../../src/helpers/tokenAmount.js"],"names":["eth","tokenAddress","amount","showSymbol","precision","amountBn","BN","fixed","decimals","symbol","ETH","token","Contract","ERC20_SYMBOL_DECIMALS_ABI","methods","call","err","ERC20_SYMBOL_BYTES32_ABI","formattedAmount","type","value"],"mappings":"2UAKgBA,GAAD,EACb;;;;;;;;KASA,MAAOC,YAAP,CAAqBC,MAArB,CAA6BC,UAAU,GAAvC,CAAgDC,SAAhD,GAA8D,MACtDC,CAAAA,QAAQ,CAAG,GAAIC,YAAJ,CAAOJ,MAAP,CAD2C,CAEtDK,KAAK,CAAG,CAAC,CAACH,SAF4C,IAIxDI,CAAAA,QAJwD,CAKxDC,MALwD,CAO5D,GAAIR,YAAY,GAAKS,UAArB,CACEF,QAAQ,CAAG,GAAIF,YAAJ,CAAO,EAAP,CADb,CAEMH,UAFN,GAGIM,MAAM,CAAG,KAHb,MAKO,CACL,GAAIE,CAAAA,KAAK,CAAG,GAAIX,CAAAA,GAAG,CAACY,QAAR,CAAiBC,gCAAjB,CAA4CZ,YAA5C,CAAZ,CAGA,GADAO,QAAQ,CAAG,GAAIF,YAAJ,EAAO,KAAMK,CAAAA,KAAK,CAACG,OAAN,CAAcN,QAAd,GAAyBO,IAAzB,EAAb,EACX,CAAIZ,UAAJ,CACE,GAAI,CACFM,MAAM,CAAG,MAAME,CAAAA,KAAK,CAACG,OAAN,CAAcL,MAAd,GAAuBM,IAAvB,EAAN,GAAuC,EACjD,CAAC,MAAOC,GAAP,CAAY,CAEZL,KAAK,CAAG,GAAIX,CAAAA,GAAG,CAACY,QAAR,CAAiBK,+BAAjB,CAA2ChB,YAA3C,CAFI,CAGZQ,MAAM,CAAG,MAAME,CAAAA,KAAK,CAACG,OAAN,CAAcL,MAAd,GAAuBM,IAAvB,EAAN,GAAuC,EAHpC,CAIZN,MAAM,CAAGA,MAAM,EAAI,sBAAOA,MAAP,CACpB,CAEJ,CAEDL,SAAS,CAAGA,SAAS,EAAII,QA5BmC,CA8B5D,KAAMU,CAAAA,eAAe,CAAG,uBAASb,QAAT,CAAmB,qBAAOG,QAAP,CAAnB,EAA4CJ,SAA5C,CAAwDG,KAAxD,CAAxB,CAEA,MAAO,CACLY,IAAI,CAAE,QADD,CAELC,KAAK,CAAEjB,UAAU,WAAMe,eAAN,aAAyBT,MAAzB,EAAoCS,eAFhD,CAIR,C","sourcesContent":["import BN from 'bn.js'\nimport { toUtf8 } from 'web3-utils'\nimport { ERC20_SYMBOL_BYTES32_ABI, ERC20_SYMBOL_DECIMALS_ABI, ETH } from './lib/token'\nimport { formatBN, tenPow } from './lib/formatBN'\n\nexport default (eth) =>\n  /**\n   * Format token amounts taking decimals into account\n   *\n   * @param {string} tokenAddress The address of the token\n   * @param {*} amount The absolute amount for the token quantity (wei)\n   * @param {bool} showSymbol Whether the token symbol will be printed after the amount\n   * @param {*} precision The number of decimal places to format to. If set, the precision is always enforced.\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */\n  async (tokenAddress, amount, showSymbol = true, precision) => {\n    const amountBn = new BN(amount)\n    const fixed = !!precision\n\n    let decimals\n    let symbol\n\n    if (tokenAddress === ETH) {\n      decimals = new BN(18)\n      if (showSymbol) {\n        symbol = 'ETH'\n      }\n    } else {\n      let token = new eth.Contract(ERC20_SYMBOL_DECIMALS_ABI, tokenAddress)\n\n      decimals = new BN(await token.methods.decimals().call())\n      if (showSymbol) {\n        try {\n          symbol = await token.methods.symbol().call() || ''\n        } catch (err) {\n          // Some tokens (e.g. DS-Token) use bytes32 for their symbol()\n          token = new eth.Contract(ERC20_SYMBOL_BYTES32_ABI, tokenAddress)\n          symbol = await token.methods.symbol().call() || ''\n          symbol = symbol && toUtf8(symbol)\n        }\n      }\n    }\n\n    precision = precision || decimals\n\n    const formattedAmount = formatBN(amountBn, tenPow(decimals), Number(precision), fixed)\n\n    return {\n      type: 'string',\n      value: showSymbol ? `${formattedAmount} ${symbol}` : formattedAmount\n    }\n  }\n"],"file":"tokenAmount.js"}